<!doctype html>
<html class="no-js">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title> - </title>
    <meta name="description" content=" - " />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="keywords" content=", " />

    <!-- CSS  Get: http://www.google.com/fonts/
    http://stackoverflow.com/questions/7985081/how-to-deploy-a-jekyll-site-locally-with-css-js-and-background-images-included
    ================================================== -->
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400,700,800|Raleway:400,200,700" rel="stylesheet" type="text/css">
    <!-- Fount Awesome -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="stylesheet" href="css/style.css" />

    <!-- Ah, the favicon.
    ================================================== -->
    <link rel="shortcut icon" href="favicon.ico">

    <!-- Open Graph: https://developers.facebook.com/docs/opengraph/howtos/maximizing-distribution-media-content/
    Twitter: https://dev.twitter.com/docs/cards/types/summary-card
    ============================== -->
    <meta property="og:title" content=""/>
    <meta property="og:site_name" content=" - "/>
    <meta property="og:url" content=" - "/>
    <meta property="og:description" content=""/>
    <meta property="og:image" content=""/>
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:title" content="">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="">

    <!-- modernizr
    ================================================== -->
    <script src="bower_components/modernizr/modernizr.js"></script>
  </head>
  <body>
    <nav class="top-bar" data-topbar role="navigation">
  <ul class="title-area">
    <li class="name">
      <h1><a href="#">My Site</a></h1>
    </li>
     <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
    <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
  </ul>

  <section class="top-bar-section">
    <!-- Right Nav Section -->
    <ul class="right">
      <li class="active"><a href="#">Right Button Active</a></li>
      <li class="has-dropdown">
        <a href="#">Right Button Dropdown</a>
        <ul class="dropdown">
          <li><a href="#">First link in dropdown</a></li>
          <li class="active"><a href="#">Active link in dropdown</a></li>
        </ul>
      </li>
    </ul>

    <!-- Left Nav Section -->
    <ul class="left">
      <li><a href="#">Left Nav Button</a></li>
    </ul>
  </section>
</nav>


    <!-- Hero -->
    <div class="hero">
      <div class="hero-unit">
        <div class="row">
          <div class="columns">
            <h1 id="project_title">
              <a href="#"><img src="/images/icon_trb_glow.png"></a>

              Trailblazer
            </h1>
            <h2>A new architecture for Rails</h2>

          </div>
        </div>
      </div>
    </div>


    <div class="row">
      <div class="columns large-3">
     <!--    <a href="https://github.com/trailblazer/www.trailblazerb.org" class="button">View on GitHub</a>
        <a class="button" href="https://github.com/trailblazer/www.trailblazerb.org/zipball/master">Download this project as a .zip file</a>
        <a class="button" href="https://github.com/trailblazer/www.trailblazerb.org/tarball/master">Download this project as a tar.gz file</a> -->

        <h5>Sidebar</h5>
        <ul class="side-nav">
          <li><a href="#">Link 1</a></li>
          <li><a href="#">Link 2</a></li>
          <li><a href="#">Link 3</a></li>
          <li><a href="#">Link 4</a></li>
        </ul>

      </div>
      <div class="columns medium-9">
        <h1 id="populating">Populating</h1>

<p>Reform has two completely separated modes for form setup. One when rendering the form and one when populating the form in <code>validate</code>.</p>

<p><a href="/gems/reform/prepopulator.html">Prepopulating</a> is helpful when you want to fill out fields (aka. <em>defaults</em>) or add nested forms before rendering.</p>

<p><a href="/gems/reform/populators.html">Populating</a> is invoked in <code>validate</code> and will add nested forms depending on the incoming hash.</p>

<p>This page discusses the latter.</p>

<p>[Populators are discussed in detail in the chapters <em>Nested Forms</em> and <em>Mastering Forms</em> of the Trailblazer book.]</p>

<h2 id="populators">Populators</h2>

<p>In <code>#validate</code>, Reform per default will try to match nested hashes to nested forms. In other words, Reform thinks that the form object graph is already matching 1-to-1 to the incoming params hash.</p>

<p>Let’s say you’re setting up the following form.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">album</span><span class="o">.</span><span class="n">songs</span><span class="o">.</span><span class="n">size</span> <span class="c1">#=&gt; 1</span>
<span class="n">form</span> <span class="o">=</span> <span class="no">AlbumForm</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">album</span><span class="p">)</span>
<span class="n">form</span><span class="o">.</span><span class="n">songs</span><span class="o">.</span><span class="n">size</span> <span class="c1">#=&gt; 1</span></code></pre></div>

<p>In <code>validate</code> you then pass in an additional <code>Song</code> hash.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">form</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="ss">songs</span><span class="p">:</span> <span class="o">[</span><span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;The Tempest&quot;</span><span class="p">},</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Nevermore&quot;</span><span class="p">}</span><span class="o">]</span><span class="p">)</span></code></pre></div>

<p>Intuitively, you will expect Reform to create an additional song with the name “Nevermore”. However, this is not how it works. Without configuration, Reform has no idea how to assign the second <code>:songs</code> fragment to the form and will raise an exception.</p>

<h2 id="the-populateifempty-option">The :populate_if_empty Option</h2>

<p>To let the form create a new model wrapped by a nested form for you use <code>:populate_if_empty</code>.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AlbumForm</span> <span class="o">&lt;</span> <span class="no">Reform</span><span class="o">::</span><span class="no">Form</span>
  <span class="n">property</span> <span class="ss">:songs</span><span class="p">,</span> <span class="ss">populate_if_empty</span><span class="p">:</span> <span class="no">Song</span> <span class="k">do</span>
    <span class="n">property</span> <span class="ss">:name</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></div>

<p>When traversing the incoming <code>songs:</code> collection, fragments without a counterpart nested form will be created for you with a new <code>Song</code> object.</p>

<p>You can also create the object yourself and leverage data from the traversed fragment, for instance, to try to find a <code>Song</code> object by name, first, before creating a new one.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AlbumForm</span> <span class="o">&lt;</span> <span class="no">Reform</span><span class="o">::</span><span class="no">Form</span>
  <span class="n">property</span> <span class="ss">:songs</span><span class="p">,</span> <span class="ss">populate_if_empty</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="no">Song</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="n">fragment</span><span class="o">[</span><span class="s2">&quot;name&quot;</span><span class="o">]</span><span class="p">)</span> <span class="ow">or</span> <span class="no">Song</span><span class="o">.</span><span class="n">new</span> <span class="p">}</span> <span class="k">do</span></code></pre></div>

<p>The result from this block will be automatically added to the form graph.</p>

<p>You can also provide an instance method on the respective form.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AlbumForm</span> <span class="o">&lt;</span> <span class="no">Reform</span><span class="o">::</span><span class="no">Form</span>
  <span class="n">property</span> <span class="ss">:songs</span><span class="p">,</span> <span class="ss">populate_if_empty</span><span class="p">:</span> <span class="ss">:populate_songs!</span> <span class="k">do</span>
    <span class="n">property</span> <span class="ss">:name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">populate_songs!</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="no">Song</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="n">fragment</span><span class="o">[</span><span class="s2">&quot;name&quot;</span><span class="o">]</span><span class="p">)</span> <span class="ow">or</span> <span class="no">Song</span><span class="o">.</span><span class="n">new</span>
  <span class="k">end</span></code></pre></div>

<p>Arguments are the currently processed hash <code>fragment</code> and <code>options</code>.</p>

<p>The result of the block will automatically assigned to the property or collection for you. Note that you can’t use the twin API in here. If you want to do fancy stuff, use <code>:populator</code>.</p>

<h2 id="the-populator-option">The :populator Option</h2>

<p>While the <code>:populate_if_empty</code> option is only called when no matching form was found for the input, the <code>:populator</code> option is always invoked and gives you maximum flexibility for population.</p>

<p>Please do <em>not</em> use both <code>:prepopulate_if_empty</code> and <code>:populator</code> for the same property.</p>

<h2 id="populator-for-collections">Populator for Collections</h2>

<p>A <code>:populator</code> for collections is executed for every collection fragment in the incoming hash.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AlbumForm</span> <span class="o">&lt;</span> <span class="no">Reform</span><span class="o">::</span><span class="no">Form</span>
  <span class="n">collection</span> <span class="ss">:songs</span><span class="p">,</span>
    <span class="ss">populator</span><span class="p">:</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">fragment</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">options</span><span class="o">|</span>
      <span class="p">(</span><span class="n">item</span> <span class="o">=</span> <span class="n">collection</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">)</span> <span class="p">?</span> <span class="n">item</span> <span class="p">:</span> <span class="n">collection</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="no">Song</span><span class="o">.</span><span class="n">new</span><span class="p">)</span> <span class="p">}</span> <span class="k">do</span>

    <span class="n">property</span> <span class="ss">:title</span>
  <span class="k">end</span></code></pre></div>

<p>The <code>:populator</code> option accepts blocks and instance method names.</p>

<p>The signature is as follows.</p>

<ul>
  <li><code>fragment</code> is the fragment of the incoming hash that matches the processed nested form.</li>
  <li><code>collection</code> is the nested form collection (manually available via <code>form.songs</code>).</li>
  <li><code>index</code> will be the index of the currently processed fragment.</li>
  <li><code>options</code></li>
</ul>

<p>Note that you manually have to check whether or not a nested form is already available (by index or ID) and then need to add it using the form API writers.</p>

<p>Another requirement is that per block invocation, the nested form has to be returned from the block. This is important for further processing of the incoming hash when values are mapped to properties by Reform (e.g. <code>title</code>).</p>

<h2 id="populator-for-single-properties">Populator for Single Properties</h2>

<p>Naturally, a single property <code>:populator</code> is only called once.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AlbumForm</span> <span class="o">&lt;</span> <span class="no">Reform</span><span class="o">::</span><span class="no">Form</span>
  <span class="n">property</span> <span class="ss">:composer</span><span class="p">,</span> <span class="ss">populator</span><span class="p">:</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">fragment</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">options</span><span class="o">|</span>
      <span class="n">model</span> <span class="o">||</span> <span class="nb">self</span><span class="o">.</span><span class="n">composer</span><span class="o">=</span> <span class="no">Artist</span><span class="o">.</span><span class="n">new</span> <span class="p">}</span> <span class="k">do</span>

    <span class="n">property</span> <span class="ss">:name</span>
  <span class="k">end</span></code></pre></div>

<p>The signature here is identical to collections, except that the <code>index</code> argument is missing for obvious reasons.</p>

<p>Again, a requirement is that the nested form has to be returned from the block.</p>

<h2 id="populating-by-id">Populating by ID</h2>

<p>[This is described in chapter <em>Authentication</em> in the Trailblazer book.]</p>

<p>Reform matches incoming hash fragments and nested forms by their order. It doesn’t know anything about IDs or other persistence mechanics.</p>

<p>You can use <code>:populator</code> to write your own matching for IDs. This is a feature that might be included into Reform since this is a frequently implemented requirement when working with persisted models.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">property</span> <span class="ss">:songs</span><span class="p">,</span>
  <span class="ss">populator</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># find out if incoming song is already added.</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">songs</span><span class="o">.</span><span class="n">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">song</span><span class="o">|</span> <span class="n">song</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">to_s</span> <span class="o">==</span> <span class="n">fragment</span><span class="o">[</span><span class="s2">&quot;id&quot;</span><span class="o">].</span><span class="n">to_s</span> <span class="p">}</span>
    <span class="n">item</span> <span class="p">?</span> <span class="n">item</span> <span class="p">:</span> <span class="n">songs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="no">Song</span><span class="o">.</span><span class="n">new</span><span class="p">)</span>
  <span class="p">}</span></code></pre></div>

<p>Note that a <code>:populator</code> requires you to add/replace/update/delete the model yourself. You have access to the form API here since the block is executed in form instance context.</p>

<p>The <code>:populator</code> block has to return the corresponding nested form.</p>

<p>This naturally works for single properties, too.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">property</span> <span class="ss">:artist</span><span class="p">,</span>
  <span class="ss">populator</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">artist</span> <span class="p">?</span> <span class="n">artist</span> <span class="p">:</span> <span class="nb">self</span><span class="o">.</span><span class="n">artist</span> <span class="o">=</span> <span class="no">Artist</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">fragment</span><span class="o">[</span><span class="s2">&quot;id&quot;</span><span class="o">]</span><span class="p">)</span>
  <span class="p">}</span></code></pre></div>

<p>It is important to check whether the respective collection item or single property already exists in the form, otherwise your graph will get out-of-sync.</p>

<h2 id="uninitialized-collections">Uninitialized Collections</h2>

<p>A problem with populators can be an uninitialized <code>collection</code> property.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">AlbumForm</span> <span class="o">&lt;</span> <span class="no">Reform</span><span class="o">::</span><span class="no">Form</span>
  <span class="n">collection</span> <span class="ss">:songs</span><span class="p">,</span> <span class="ss">populate_if_empty</span><span class="p">:</span> <span class="no">Song</span> <span class="k">do</span>
    <span class="n">property</span> <span class="ss">:title</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">album</span> <span class="o">=</span> <span class="no">Album</span><span class="o">.</span><span class="n">new</span>
<span class="n">form</span>  <span class="o">=</span> <span class="no">AlbumForm</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">album</span><span class="p">)</span>

<span class="n">album</span><span class="o">.</span><span class="n">songs</span> <span class="c1">#=&gt; nil</span>
<span class="n">form</span><span class="o">.</span><span class="n">songs</span>  <span class="c1">#=&gt; nil</span>

<span class="n">form</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="ss">songs</span><span class="p">:</span> <span class="o">[</span><span class="p">{</span><span class="ss">title</span><span class="p">:</span> <span class="s2">&quot;Friday&quot;</span><span class="p">}</span><span class="o">]</span><span class="p">)</span>
<span class="c1">#=&gt; NoMethodError: undefined method `original&#39; for nil:NilClass</span></code></pre></div>

<p>What happens is as follows.</p>

<ol>
  <li>In <code>validate</code>, the form can’t find a corresponding nested songs form and calls the <code>populate_if_empty</code> code.</li>
  <li>The populator will create a <code>Song</code> model and assign it to the parent form via <code>form.songs &lt;&lt; Song.new</code>.</li>
  <li>This crashes, as <code>form.songs</code> is <code>nil</code>.</li>
</ol>

<p>The solution is to initialize your object correctly. This is per design. It is your job to do that as Reform/Disposable is likely to do it wrong.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">album</span> <span class="o">=</span> <span class="no">Album</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">songs</span><span class="p">:</span> <span class="o">[]</span><span class="p">)</span>
<span class="n">form</span>  <span class="o">=</span> <span class="no">AlbumForm</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">album</span><span class="p">)</span></code></pre></div>

<p>With ORMs, the setup happens automatically, this only appears when using <code>Struct</code> or other POROs as models.</p>

<h2 id="internals">Internals</h2>

<p><code>:populator</code> options are called via the <code>:instance</code> hook in the deserializer. They disable <code>:setter</code>, hence you have to set newly created twins yourself.</p>

<p>(how models automatically become twinned when assigning)</p>


      </div>
    </div>

    <!-- FOOTER  -->
    <footer>
      <div class="row">
        <div class="columns">
          <p>Trailblazer maintained by <a href="https://github.com/trailblazer">trailblazer</a></p>
        </div>
      </div>
    </footer>


    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="bower_components/jquery/jquery.js"><\/script>')</script>
    <script src="js/plugins.js"></script>
    <script src="bower_components/foundation/js/foundation.min.js"></script>
    <script src="js/script.js"></script>

  </body>
</html>
