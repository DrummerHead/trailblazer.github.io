<!doctype html>
<html class="no-js">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Trailblazer: Cells API</title>
<meta name="description" content="Cells API - Trailblazer" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="keywords" content=", " />

<link href="//fonts.googleapis.com/css?family=Open+Sans:300, 400,700,800|Raleway:400,200,700" rel="stylesheet" type="text/css">

<link rel="stylesheet" href="/css/style.css" />
<link rel="shortcut icon" href="/favicon.ico">

<link rel="stylesheet" href="/css/dark.css">
<script src="/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/bower_components/modernizr/modernizr.js"></script>

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">

<meta property="og:title" content="Cells API"/>
<meta property="og:site_name" content="Trailblazer"/>
<meta property="og:url" content="http://trailblazer.to/gems/cells/api.html"/>
<meta property="og:description" content=""/>
<meta property="og:image" content="http://trailblazer.to/images/go-trailblazer.jpg"/>
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@apotonick">
<meta name="twitter:title" content="Cells API">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="http://trailblazer.to/images/go-trailblazer.jpg">

  </head>

  <body class="cells-body">
    <!-- Top Bar -->
    <nav class="top-bar" data-topbar role="navigation">
  <ul class="title-area">
    <li class="name">
      <h1><a href="/"><img style="height: 25px;" src="/images/logo-top.svg"></a></h1>
    </li>
    <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
  </ul>

  <section class="top-bar-section">
    <ul class="right">
    <li><a href="/newsletter/"><img alt="TRB Newsletter" src="https://img.shields.io/badge/TRB-newsletter-lightgrey.svg"></a></li>
    <li class="divider"></li>
    <li><a href="https://gitter.im/trailblazer/chat">Support chat</a></li>
    <li class="divider"></li>
    <li><a href="/guides">Guides</a></li>
    <li class="divider"></li>
      <li class="has-dropdown">
        <a href="#">Gems</a>
        <ul class="dropdown">
          <li class=""><a href="/gems/cells">Cells</a></li>
          <li class=""><a href="/gems/operation">Operation</a></li>
          <li class=""><a href="/gems/reform">Reform</a></li>
          <li class=""><a href="/gems/representable">Representable</a></li>
          <li class=""><a href="/gems/roar">Roar</a></li>
          <li class=""><a href="/gems/disposable">Disposable</a></li>
        </ul>
      </li>
      <li class="divider"></li>
      <li class="has-form">
        <a href="https://leanpub.com/trailblazer" class="button radius secondary">Get the book</a>
      </li>
    </ul>
  </section>
</nav>


    <!-- Hero -->
    <div class="hero gems-hero cells-hero">
      <div class="hero-unit">
        <div class="row">
          <div class="columns">
            <h1 id="project_title">
              Cells
            </h1>
          </div>
        </div>
      </div>
    </div>



    <div class="row">
      <div class="columns large-3 sidebar">
        <nav>
  <ul class="side-nav">

    <li class="heading">
        <a href="/gems/operation">
            <i class="fa fa-caret-square-o-right" aria-hidden="true"></i> OPERATION
        </a>
    </li>
    <li><a href="/gems/operation/api.html">API</a></li>
    <li><a href="/gems/operation/contract.html">Contract</a></li>
    <li><a href="/gems/operation/builder.html">Builder</a></li>
    <li><a href="/gems/operation/collection.html">Collection</a></li>
    <li><a href="/gems/operation/callback.html">Callback</a></li>
    <li><a href="/gems/operation/controller.html">Controller</a></li>
    <li><a href="/gems/operation/representer.html">Representer</a></li>
    <li><a href="/gems/operation/model.html">Model</a></li>
    <li><a href="/gems/operation/policy.html">Policy</a></li>
    <li class="divider"></li>

    <li class="heading">
        <a href="/gems/cells">
            <i class="fa fa-caret-square-o-right" aria-hidden="true"></i> CELLS
        </a>
    </li>
    <li><a href="/gems/cells/api.html">API</a></li>
    <li><a href="/gems/cells/trailblazer.html">Trailblazer::Cell</a></li>
    <li><a href="/gems/cells/testing.html">Testing</a></li>
    <li><a href="/gems/cells/render.html">Rendering</a></li>
    <li><a href="/gems/cells/rails.html">Rails</a></li>
    <li><a href="/gems/cells/templates.html">Templates</a></li>
    <li><a href="/gems/cells/troubleshooting.html">Troubleshooting</a></li>
    <li class="divider"></li>

    <li class="heading">
        <a href="/gems/reform">
            <i class="fa fa-caret-square-o-right" aria-hidden="true"></i> REFORM
        </a>
    </li>
    <li><a href="/gems/reform/api.html">API</a></li>
    <li><a href="/gems/reform/populator.html">Populator</a></li>
    <li><a href="/gems/reform/nested_forms.html">Nested Forms</a></li>
    <li><a href="/gems/reform/prepopulator.html">Prepopulator</a></li>
    <li><a href="/gems/reform/validation.html">Validation</a></li>
    <li><a href="/gems/reform/debugging.html">Debugging</a></li>
    <li><a href="/gems/reform/upgrading-guide.html">Upgrading Guide</a></li>
    <li class="divider"></li>

    <li class="heading">
        <a href="/gems/representable">
            <i class="fa fa-caret-square-o-right" aria-hidden="true"></i> REPRESENTABLE
        </a>
    </li>
    <li><a href="/gems/representable/getting-started.html">Getting Started</a></li>
    <li><a href="/gems/representable/3.0/api.html">API</a></li>
    <li><a href="/gems/representable/3.0/function-api.html">Function API</a></li>
    <li><a href="/gems/representable/3.0/populator.html">Populator</a></li>
    <!-- <li><a href="/gems/representable/architecture.html">Architecture</a></li> -->
    <li><a href="/gems/representable/3.0/xml.html">XML</a></li>
    <li><a href="/gems/representable/3.0/yaml.html">YAML</a></li>
    <li><a href="/gems/representable/upgrading-guide.html">Upgrading Guide</a></li>
    <li class="divider"></li>

    <li class="heading">
        <a href="/gems/roar">
            <i class="fa fa-caret-square-o-right" aria-hidden="true"></i> ROAR
        </a>
    </li>
    <li><a href="/gems/roar/jsonapi.html">JSON API</a></li>
    <li class="divider"></li>

    <li class="heading">
        <a href="/gems/disposable">
            <i class="fa fa-caret-square-o-right" aria-hidden="true"></i> DISPOSABLE
        </a>
    </li>
    <li><a href="/gems/disposable/api.html">API</a></li>
    <li><a href="/gems/disposable/default.html">Default</a></li>
    <li><a href="/gems/disposable/callback.html">Callback</a></li>
    <li class="divider"></li>

    <li class="heading">
        <a href="/guides">
            <i class="fa fa-caret-square-o-right" aria-hidden="true"></i> GUIDES
        </a>
    </li>
    <li><a href="/guides/sinatra/getting-started.html">Sinatra: Getting Started</a></li>
    <li><a href="/guides/grape.html">Grape</a></li>
  </ul>
</nav>

      </div>
      <div class="columns medium-9 code-content">
        <h1 id="cells-api">Cells: API</h1>

<p>A cell is an object that can render views. It represents a fragment of the page, or the entire page.</p>

<p>Sometimes they’re also called <em>object-oriented partials</em>.</p>

<p>The object has to define at least one method which in turn has to return the fragment. Per convention, this is <code>#show</code>. In this public method, you may compile arbitrary strings or <code>render</code> a cell view.</p>

<p>The return value of this public method (also called <em>state</em>) is what will be the rendered in the view using the cell.</p>

<h2 id="anatomy">Anatomy</h2>

<p>Cells are usually derived from <code>Cell::ViewModel</code>.</p>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
  def show
    render # renders app/cells/comment/show.haml
  end
end
</code></pre>

<p>When the <code>CommentCell</code> cell is invoked, its <code>show</code> method is called, the view is rendered, and returned as a HTML string.</p>

<p>This snippet illustrates a <em>suffix cell</em>, because it is following the outdated Rails-style naming and file structure. We encourage you to use <a href="trailblazer.html">Trailblazer cells</a>. However, this document mostly specifies generic API.</p>

<h2 id="show">Show</h2>

<p>As per convention, <code>#show</code> is the only public method of a cell class.</p>

<p>The return value of this method is what gets rendered as the cell.</p>

<pre><code class="language-ruby">def show
  "I don't like templates!"
end
</code></pre>

<p>You’re free to use return whatever string you desire, use your own rendering engine, or use cells <code>render</code> for templates.</p>

<h2 id="manual-invocation">Manual Invocation</h2>

<p>In its purest form, a cell can be rendered as follows.</p>

<pre><code class="language-ruby">Comment::Cell.new(comment).() #=&gt; "I don't like templates!"
</code></pre>

<p>This can be split up into two steps: initialization and invocation.</p>

<h2 id="initialize">Initialize</h2>

<p>You may instantiate cells manually, wherever you want.</p>

<pre><code class="language-ruby">cell = Comment::Cell.new(comment)
</code></pre>

<p>This is helpful in environments where the helpers are not available, e.g. a Rails mailer or a <code>Lotus::Action</code>.</p>

<p>Note that usually you pass in an arbitrary object into the cell, the <em>“model”</em>. Here, this is the <code>comment</code> instance.</p>

<h2 id="model">Model</h2>

<p>The model you pass into the cell’s constructor is completely up to you! It could be an ActiveRecord instance, a <code>Struct</code>, or an array of items.</p>

<p>The model is available via the <code>model</code> reader.</p>

<pre><code class="language-ruby">def show
  model.rude? "Offensive content." : render
end
</code></pre>

<p>The term <em>model</em> is really not to be confused with the way Rails uses it - it can be just anything.</p>

<h2 id="property">Property</h2>

<p>Cells allow a short form to access model’s attributes using the <code>property</code> class method.</p>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
  property :email #=&gt; model.email

  def show
    model.email #=&gt; "s@trb.to"
    email #=&gt; "s@trb.to"
  end
end
</code></pre>

<p>Using <code>::property</code> will create a convenient reader method for you to the model.</p>

<h2 id="options">Options</h2>

<p>Along with the model, you may also pass arbitrary options into the cell, for example the current user.</p>

<pre><code class="language-ruby">cell = Comment::Cell.new(comment, current_user: current_user)
</code></pre>

<p>In the cell, you can access any options using  the <code>options</code> reader.</p>

<pre><code class="language-ruby">def show
  options[:current_user] ? render : "Not logged in!"
end
</code></pre>

<h2 id="invocation">Invocation</h2>

<p>Once you got the cell instance, you may call the rendering state. This happens via <code>ViewModel#call</code>.</p>

<pre><code class="language-ruby">cell.call(:show)
</code></pre>

<p>It’s a common idiom in Ruby to skip the explicit <code>call</code> method name. The next snippet does the same as the above.</p>

<pre><code class="language-ruby">cell.(:show)
</code></pre>

<p>Since <code>show</code> is the default state, you may simple <em>call</em> the cell without arguments.</p>

<pre><code>cell.() #=&gt; cell.(:show)
</code></pre>

<p>Note that in Rails controller views, this will be called automatically via cell’s <code>ViewModel#to_s</code> method.</p>

<h2 id="call">Call</h2>

<p>Always invoke cell methods via <code>call</code>. This will ensure that caching - if configured - is performed properly.</p>

<pre><code>CommentCell.new(comment).(:show)
</code></pre>

<p>As discussed, this will call the cell’s <code>show</code> method and return the rendered fragment.</p>

<p>Note that you can invoke more than one state on a cell, if desired.</p>

<pre><code class="language-ruby">- cell = CommentCell.new(Comment.last)      # instantiate.
= cell.call(:show)                          # render main fragment.
= content_for :footer, cell.(:footer)       # render footer.
</code></pre>

<p>See how you can combine cells with global helpers like <code>content_for</code>?</p>

<p>You can also provide additional arguments to <code>call</code>.</p>

<pre><code class="language-ruby">cell.(:show, Time.now)
</code></pre>

<p>All arguments after the method name are passed to the invoked method.</p>

<pre><code class="language-ruby">def show(when)
  when #=&gt; Now!
end
</code></pre>

<p>Even blocks are allowed.</p>

<pre><code class="language-ruby">cell.(:show) { "Yay!" }
</code></pre>

<p>Again, the block is passed through to the invoked method.</p>

<pre><code class="language-ruby">def show(&amp;block)
  yield #=&gt; "Yay!"
end
</code></pre>

<p>This is particularly interesting when passing the block to <code>render</code> and using <code>yield</code> in the view. See <a href="#render">render</a>’s docs for that.</p>

<h2 id="default-show">Default Show</h2>

<p>Per default, every cell derived from <code>Cell::ViewModel</code> has a built-in <code>show</code> method.</p>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
  # #show is inherited.
end
</code></pre>

<p>The implementation looks as follows.</p>

<pre><code class="language-ruby">def show(&amp;block)
  render &amp;block
end
</code></pre>

<p>An optional block is always passed to the <code>render</code> method.</p>

<p>Of course, you’re free to override <code>show</code> to do whatever it needs to do.</p>

<h2 id="instantiation-helper">Instantiation Helper</h2>

<p>In most environments you will instantiate cells with the <code>concept</code> or <code>cell</code> helper which internally does exactly the same as the manual invocation.</p>

<pre><code class="language-ruby">cell = cell(:comment, comment)
</code></pre>

<p>This is identical to</p>

<pre><code class="language-ruby">cell = CommentCell.new(comment)
</code></pre>

<p>Depending on your environment, the <code>cell</code> helper might inject dependencies into the created cell. For example, in Rails, the controller is passed on into the cell behind the scenes. When manually instantiating cells, you must not forget to do so, too.</p>

<p>The <code>cell</code> helper also allows passing in the cell constant. This means, it won’t try to infer the class constant name.</p>

<pre><code class="language-ruby">cell = cell(CommentCell, comment)
</code></pre>

<h2 id="file-structure">File Structure</h2>

<p>Having a cell to represent a fragment of your page is one thing. The real power, whatsoever, comes when rendering templates in cells. The <code>render</code> method does just that.</p>

<p>In a suffix environment, Cells expects the following file layout.</p>

<pre><code>├── app
│   ├── cells
│   │   └── comment_cell.rb
│   │   └── comment
│   │       └── show.haml
</code></pre>

<p>Every cell - unless configured otherwise - has its own view  directory named after the cell’s name (<code>comment</code>). Views do only have one extension to identify the template’s format (<code>show.haml</code>). Again, you’re free to provide arbitrary additional extensions.</p>

<p>Note that the <em>suffix</em> style is getting superseded by the <a href="trailblazer.html">Trailblazer</a>-style naming and file structure.</p>

<h2 id="render">Render</h2>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
  def show
    render # renders show.haml.
  end
end
</code></pre>

<p>A simple <code>render</code> will implicitly figure out the method (or state) name and attempt to render that view. Here, the file will be resolved to <code>app/cells/comment/show.haml</code>.</p>

<p>Note that <code>render</code> literally renders the template and returns the HTML string. This allows you to call render multiple times, concatenate, and so on.</p>

<pre><code class="language-ruby">def show
  render + render(:footer) + "&lt;hr/&gt;"
end
</code></pre>

<p>You can provide an explicit view name as the first argument.</p>

<pre><code class="language-ruby">def show
  render :item # renders item.haml
end
</code></pre>

<p>When providing more than one argument to <code>render</code>, you have to use the <code>:view</code> option.</p>

<pre><code class="language-ruby">def show
  render view: :item # renders item.haml
end
</code></pre>

<p>If you like the clunky Rails-style file naming, you’re free to add a format to the view.</p>

<pre><code class="language-ruby">render "shot.html" # renders show.html.haml
</code></pre>

<p>You can pass locals to the view using <code>:locals</code>.</p>

<pre><code class="language-ruby">render locals: { logged_in: options[:current_user] }
</code></pre>

<h2 id="instance-methods">Instance Methods</h2>

<p>While it is fine to use locals or instance variables in the view to access data, the preferred way is invoking instance methods in the view.</p>

<pre><code>%h1 Show comment

= body
= author_link
</code></pre>

<p>Every method call in the view is dispatched to the cell instance. You have to define your “helpers” there.</p>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
  property :body # creates #body reader.

  def author_link
    url_for model.author.name, model.author
  end
end
</code></pre>

<p>This allows slim, logic-less views.</p>

<p>Note that you can use Rails in the instance level, too, if you’re in a Rails environment.</p>

<h2 id="yield">Yield</h2>

<p>A block passed to the cell constructor is passed on to the state method.</p>

<pre><code class="language-ruby">CommentCell.new(comment) { "Yay!" }
cell(:comment, comment)  { "Yay!" }
</code></pre>

<p>It’s up to you if you want to use this block, or provide your own.</p>

<pre><code class="language-ruby">def show(&amp;block)
  render(&amp;block)
end
</code></pre>

<p>Passing the block <code>render</code> allows yielding it in the view.</p>

<pre><code>%h1 Comment

= yield
</code></pre>

<h2 id="collection">Collection</h2>

<p>Instead of manually iterating an array of models and concatenating the output of the item cell, you can use the <code>:collection</code> feature.</p>

<pre><code class="language-ruby">cell(:comment, collection: Comment.all).()
</code></pre>

<p>This will instantiate a cell per iterated model, invoke <code>call</code> and join the output into one fragment.</p>

<p>Pass the method name to <code>call</code> when you want to invoke a state different to <code>show</code>.</p>

<pre><code class="language-ruby">cell(:comment, collection: Comment.all).(:item)
</code></pre>

<p>You’re free to pass additional options to the call.</p>

<pre><code class="language-ruby">cell(:comment, collection: comments, size: comments.size).()
</code></pre>

<p>This instantiates each collection cell as follows.</p>

<pre><code class="language-ruby">CommentCell.new(comment, size: 9)
</code></pre>

<p>The <code>join</code> method allows to customize the cell invocation. The block’s return value is autmatically joined.</p>

<pre><code class="language-ruby">cell(:comment, collection: Comment.all).join do |cell, i|
  i.odd? cell.(:odd) : cell(:even)
end
</code></pre>

<p>An optional separator string can be passed to <code>join</code> when it concatenates the item fragments.</p>

<pre><code class="language-ruby">cell(:comment, collection: Comment.all).join("&lt;hr/&gt;") do |cell, i|
</code></pre>

<h2 id="external-layout">External Layout</h2>

<p>Since Cells 4.1, you can instruct your cell to use a second cell as a wrapper. This will first render your actual content cell, then pass the content via a block to the layout cell.</p>

<p>Cells desiring to be wrapped in a layout have to include <code>Layout::External</code>.</p>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
  include Layout::External
end
</code></pre>

<p>The layout cell usually can be an empty subclass.</p>

<pre><code class="language-ruby">class LayoutCell &lt; Cell::ViewModel
end
</code></pre>

<p>Its <code>show</code> view must contain a <code>yield</code> to insert the content.</p>

<pre><code>!!!
%html
  %head
    %title= "Gemgem"
    = stylesheet_link_tag 'application', media: 'all'
    = javascript_include_tag 'application'
  %body
    = yield
</code></pre>

<p>The layout cell class is then injected into the actual invocation using <code>:layout</code>.</p>

<pre><code class="language-ruby">cell(:comment, comment, layout: LayoutCell)
</code></pre>

<p>The context object will automatically be passed to the layout cell.</p>

<p>Note that <code>:layout</code> also works in combination with <code>:collection</code>.</p>

<h2 id="view-paths">View Paths</h2>

<p>Per default, the cell’s view path is set to <code>app/cells</code>. You can set any number of view paths for the template file lookup.</p>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
  self.view_paths = ["app/views"]
</code></pre>

<h2 id="template-formats">Template Formats</h2>

<p>Cells provides a handful of popular Erb, Haml, etc.</p>

<p>Various template engines are supported but need to be added to your Gemfile.</p>

<ul>
  <li><a href="https://github.com/trailblazer/cells-erb">cells-erb</a></li>
  <li><a href="https://github.com/trailblazer/cells-hamlit">cells-hamlit</a> We strongly recommend using <a href="https://github.com/k0kubun/hamlit">Hamlit</a> as a Haml replacement.</li>
  <li><a href="https://github.com/trailblazer/cells-haml">cells-haml</a> Make sure to bundle Haml 4.1: <code>gem "haml", github: "haml/haml", ref: "7c7c169"</code>. Use <code>cells-hamlit</code> instead.</li>
  <li><a href="https://github.com/trailblazer/cells-slim">cells-slim</a></li>
</ul>

<pre><code class="language-ruby">gem "cells-erb"
</code></pre>

<p>In Rails, this is all you need to do. In other environments, you need to include the respective module into your cells.</p>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
  include ::Cell::Erb # or Cell::Hamlit, or Cell::Haml, or Cell::Slim
end
</code></pre>

<h2 id="html-escaping">HTML Escaping</h2>

<p>Cells per default does no HTML escaping, anywhere. This is one of the reasons that makes Cells faster than Rails.</p>

<p>Include <code>Escaped</code> to make property readers return escaped strings.</p>

<pre><code>class CommentCell &lt; Cell::ViewModel
  include Escaped
  property :title
end

song.title                 #=&gt; "&lt;script&gt;Dangerous&lt;/script&gt;"
Comment::Cell.(song).title #=&gt; &amp;lt;script&amp;gt;Dangerous&amp;lt;/script&amp;gt;
</code></pre>

<p>Only strings will be escaped via the property reader.</p>

<p>You can suppress escaping manually.</p>

<pre><code>def raw_title
  "#{title(escape: false)} on the edge!"
end
</code></pre>

<p>Of course, this works in views, too.</p>

<pre><code>&lt;%= title(escape: false) %&gt;
</code></pre>

<h2 id="context-object">Context Object</h2>

<p>Per default, every cell maintains a context object. When <a href="#nesting">nesting cells</a>, this object is passed on automatically. To add objects to the context, use the <code>:context</code> option.</p>

<pre><code class="language-ruby">cell("comment", comment, context: { user: current_user })
</code></pre>

<p>Reading from the context works via the <code>context</code> method.</p>

<pre><code class="language-ruby">def show
  context[:user] #=&gt; &lt;User ..&gt;
  # ..
end
</code></pre>

<p>The context object is handy when dependencies need to be passed down (or up, when using layouts) a cell hierarchy.</p>

<h2 id="nesting">Nesting</h2>

<p>You can invoke cells in cells. This happens with the <code>cell</code> helper.</p>

<pre><code class="language-ruby">def show
  html = cell(:comment_detail, model)
  # ..
end
</code></pre>

<p>The <code>cell</code> helper will automatically pass the context object to the nested cell.</p>

<h2 id="view-inheritance">View Inheritance</h2>

<p>Cells can inherit code from each other with Ruby’s inheritance.</p>

<pre><code class="language-ruby">class CommentCell &lt; Cell::ViewModel
end

class PostCell &lt; CommentCell
end
</code></pre>

<p>Even cooler, <code>PostCell</code> will now inherit views from <code>CommentCell</code>.</p>

<pre><code class="language-ruby">PostCell.prefixes #=&gt; ["app/cells/post", "app/cells/comment"]
</code></pre>

<p>When views can be found in the local <code>post</code> directory, they will be looked up in <code>comment</code>. This starts to become helpful when using <a href="#nested-cells">composed cells</a>.</p>

<p>If you only want to inherit views, not the entire class, use <code>::inherit_views</code>.</p>

<pre><code class="language-ruby">class PostCell &lt; Cell::ViewModel
  inherit_views Comment::Cell
end

PostCell.prefixes #=&gt; ["app/cells/post", "app/cells/comment"]
</code></pre>

<h2 id="caching">Caching</h2>

<p>Cells allow you to cache per state. It’s simple: the rendered result of a state method is cached and expired as you configure it.</p>

<p>To cache forever, don’t configure anything</p>

<pre><code class="language-ruby">class CartCell &lt; Cell::Rails
  cache :show

  def show
    render
  end
</code></pre>

<p>This will run <code>#show</code> only once, after that the rendered view comes from the cache.</p>

<h2 id="cache-options">Cache Options</h2>

<p>Note that you can pass arbitrary options through to your cache store. Symbols are evaluated as instance methods, callable objects (e.g. lambdas) are evaluated in the cell instance context allowing you to call instance methods and access instance variables. All arguments passed to your state (e.g. via <code>render_cell</code>) are propagated to the block.</p>

<pre><code class="language-ruby">cache :show, :expires_in =&gt; 10.minutes
</code></pre>

<p>If you need dynamic options evaluated at render-time, use a lambda.</p>

<pre><code class="language-ruby">cache :show, :tags =&gt; lambda { |*args| tags }
</code></pre>

<p>If you don’t like blocks, use instance methods instead.</p>

<pre><code class="language-ruby">class CartCell &lt; Cell::Rails
  cache :show, :tags =&gt; :cache_tags

  def cache_tags(*args)
    # do your magic..
  end
</code></pre>

<h2 id="conditional-caching">Conditional Caching</h2>

<p>The <code>:if</code> option lets you define a condition. If it doesn’t return a true value, caching for that state is skipped.</p>

<pre><code class="language-ruby">cache :show, :if =&gt; lambda { |*| has_changed? }
</code></pre>

<h2 id="cache-keys">Cache Keys</h2>

<p>You can expand the state’s cache key by appending a versioner block to the <code>::cache</code> call. This way you can expire state caches yourself.</p>

<pre><code class="language-ruby">class CartCell &lt; Cell::Rails
  cache :show do |options|
    order.id
  end
</code></pre>

<p>The versioner block is executed in the cell instance context, allowing you to access all stakeholder objects you need to compute a cache key. The return value is appended to the state key: <code>"cells/cart/show/1"</code>.</p>

<p>As everywhere in Rails, you can also return an array.</p>

<pre><code class="language-ruby">class CartCell &lt; Cell::Rails
  cache :show do |options|
    [id, options[:items].md5]
  end
</code></pre>

<p>Resulting in: <code>"cells/cart/show/1/0ecb1360644ce665a4ef"</code>.</p>

<h2 id="debugging-cache">Debugging Cache</h2>

<p>When caching is turned on, you might wanna see notifications. Just like a controller, Cells gives you the following notifications.</p>

<ul>
  <li><code>write_fragment.action_controller</code> for cache miss.</li>
  <li><code>read_fragment.action_controller</code> for cache hits.</li>
</ul>

<p>To activate notifications, include the <code>Notifications</code> module in your cell.</p>

<pre><code class="language-ruby">class Comment::Cell &lt; Cell::Rails
  include Cell::Caching::Notifications
</code></pre>

<h2 id="cache-inheritance">Cache Inheritance</h2>

<p>Cache configuration is inherited to derived cells.</p>

<h2 id="testing-caching">Testing Caching</h2>

<p>If you want to test it in <code>development</code>, you need to put <code>config.action_controller.perform_caching = true</code> in <code>development.rb</code> to see the effect.</p>

      </div>
    </div>

    <!-- Footer -->
<section class="sub-section top-footer">
  <div class="row">
	<div class="columns medium-6">
		<h3>Newsletter</h3>
		<p>
			Stay on top of what’s happening in Trailblazer.
		</p>
			<div class="row">
				<div id="mc_embed_signup">
		     	<form action="//trailblazerb.us8.list-manage.com/subscribe/post?u=bbe5021ab6fbdc94a16f0d036&amp;id=a69f6e4652" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>

						<div class="columns large-9 medium-12 ">
							<div class="row collapse prefix-radius">
				        <div class="small-8 medium-7 large-8 columns">
				        	<div id="mc_embed_signup_scroll">
				        		<div class="mc-field-group">
									  	<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="youremail@trailblazer.to">
									  </div>
									  <div id="mce-responses" class="clear">
									    <div class="response" id="mce-error-response" style="display:none"></div>
									    <div class="response" id="mce-success-response" style="display:none"></div>
									  </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
									  <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_bbe5021ab6fbdc94a16f0d036_a69f6e4652" tabindex="-1" value=""></div>

				        	</div>
				        </div>
				        <div class="small-4 medium-5 large-4 columns">
				          <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button postfix secondary">
				        </div>
				      </div>
						</div>
					</form>
				</div>
				<script type='text/javascript' src='//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js'></script><script type='text/javascript'>(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';}(jQuery));var $mcj = jQuery.noConflict(true);</script>
			</div>
		<p>
			And check out the <a href="/newsletter/">archive of newsletters</a>!
		</p>


	</div>
	<div class="columns medium-6">
		<h3>The Book</h3>
		<p>Learn how to built a Rails app with Trailblazer, step-by-step.</p>
		<a href="/books/trailblazer.html" class="button radius tiny secondary">Check Out Book!</a>
	</div>
</div>


</section>

<footer>
  <div class="row">
    <div class="columns medium-4">
      <div class="logo-box">
        <a href="/"><img src="/images/icon_trb.png">
        </a>
      </div>
    </div>
    <div class="columns medium-8">
      <div class="row">
        <div class="columns medium-6">
          <h4>
            Trailblazer
          </h4>
          <ul class="no-bullet">
            <li><a href="https://gitter.im/trailblazer/chat">Gitter chat</a></li>
            <li><a href="https://leanpub.com/trailblazer">The book</a></li>
          </ul>
        </div>
        <div class="columns medium-6">
          <h4>
            Follow Us
          </h4>
          <ul class="inline-list">
            <li>
              <a href="https://github.com/trailblazer">
                <i class="footer-icon github-icon"></i>
              </a>
            </li>
            <li>
              <a href="https://twitter.com/apotonick">
                <i class="footer-icon twitter-icon"></i>
              </a>
            </li>
          </ul>
        </div>
      </div>
      <p class="copyright">
        Trailblazer is created by <a href="https://github.com/apotonick">Nick Sutterer</a> and awesome friends.
      </p>
      <p class="copyright">
        Site designed and handcoded with love by <a href="https://twitter.com/noeliacabane">Noelia Cabane</a>
      </p>
    </div>
  </div>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69514939-1', 'auto');
  ga('send', 'pageview');

</script>

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/bower_components/jquery/jquery.js"><\/script>')</script>
<script src="/javascripts/plugins.js"></script>
<script src="/bower_components/foundation/js/foundation.min.js"></script>
<script src="/javascripts/script.js"></script>

<script src="/bower_components/anchor-js/anchor.js"></script>
<script>
  anchors.add(".code-content h2, .sub-section h2");
</script>


<script>
  $(document).foundation();
</script>

  </body>
</html>
