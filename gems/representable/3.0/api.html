<!doctype html>
<html class="no-js">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Trailblazer: Representable API</title>
<meta name="description" content="Representable API - Trailblazer" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="keywords" content=", " />

<link href="//fonts.googleapis.com/css?family=Open+Sans:300, 400,700,800|Raleway:400,200,700" rel="stylesheet" type="text/css">

<link rel="stylesheet" href="/css/style.css" />
<link rel="shortcut icon" href="/favicon.ico">

<link rel="stylesheet" href="/css/dark.css">
<script src="/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/bower_components/modernizr/modernizr.js"></script>

<meta property="og:title" content="Representable API"/>
<meta property="og:site_name" content="Trailblazer"/>
<meta property="og:url" content="http://trailblazer.to"/>
<meta property="og:description" content=""/>
<meta property="og:image" content="http://trailblazer.to/images/go-trailblazer.jpg"/>
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@apotonick">
<meta name="twitter:title" content="Representable API">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="http://trailblazer.to/images/go-trailblazer.jpg">

  </head>

  <body class="representable-body">
    <!-- Top Bar -->
    <nav class="top-bar" data-topbar role="navigation">
  <ul class="title-area">
    <li class="name">
      <h1><a href="/"><img style="height: 25px;" src="/images/logo-top.svg"></a></h1>
    </li>
    <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
  </ul>

  <section class="top-bar-section">
    <ul class="right">
    <li><a href="/newsletter/"><img alt="TRB Newsletter" src="https://img.shields.io/badge/TRB-newsletter-lightgrey.svg"></a></li>
    <li><a href="https://gitter.im/trailblazer/chat">Support chat</a></li>
    <li class="divider"></li>
      <li class="has-dropdown">
        <a href="#">Gems</a>
        <ul class="dropdown">
          <li class=""><a href="/gems/cells">Cells</a></li>
          <li class=""><a href="/gems/operation">Operation</a></li>
          <li class=""><a href="/gems/reform">Reform</a></li>
          <li class=""><a href="/gems/representable">Representable</a></li>
          <li class=""><a href="/gems/roar">Roar</a></li>
          <li class=""><a href="/gems/disposable">Disposable</a></li>
        </ul>
      </li>
      <li class="divider"></li>
      <li class="has-form">
        <a href="https://leanpub.com/trailblazer" class="button radius secondary">Get the book</a>
      </li>
    </ul>
  </section>
</nav>


    <!-- Hero -->
    <div class="hero gems-hero representable-hero">
      <div class="hero-unit">
        <div class="row">
          <div class="columns">
            <h1>
              Representable
            </h1>
          </div>
        </div>
      </div>
    </div>



    <div class="row">
      <div class="columns large-3 sidebar">
        <nav>
  <ul class="side-nav">

    <li class="heading"><a href="/gems/operation">operation</a></li>
    <li><a href="/gems/operation/api.html">API</a></li>
    <li><a href="/gems/operation/builder.html">Builder</a></li>
    <li><a href="/gems/operation/collection.html">Collection</a></li>
    <li><a href="/gems/operation/callback.html">Callback</a></li>
    <li><a href="/gems/operation/controller.html">Controller</a></li>
    <li><a href="/gems/operation/representer.html">Representer</a></li>
    <li><a href="/gems/operation/model.html">Model</a></li>
    <li><a href="/gems/operation/policy.html">Policy</a></li>
    <li class="divider"></li>

    <li class="heading"><a href="/gems/cells">cells</a></li>
    <li><a href="/gems/cells/api.html">API</a></li>
    <li><a href="/gems/cells/testing.html">Testing</a></li>
    <li><a href="/gems/cells/render.html">Rendering</a></li>
    <li><a href="/gems/cells/rails.html">Rails</a></li>
    <li><a href="/gems/cells/helpers.html">Helpers</a></li>
    <li><a href="/gems/cells/templates.html">Templates</a></li>
    <li><a href="/gems/cells/troubleshooting.html">Troubleshooting</a></li>
    <li class="divider"></li>

    <li class="heading"><a href="/gems/reform">Reform</a></li>
    <li><a href="/gems/reform/populator.html">Populator</a></li>
    <li><a href="/gems/reform/nested_forms.html">Nested Forms</a></li>
    <li><a href="/gems/reform/prepopulator.html">Prepopulator</a></li>
    <li><a href="/gems/reform/validation.html">Validation</a></li>
    <li><a href="/gems/reform/debugging.html">Debugging</a></li>
    <li><a href="/gems/reform/rails.html">Rails</a></li>
    <li><a href="/gems/reform/upgrading-guide.html">Upgrading Guide</a></li>
    <li class="divider"></li>

    <li class="heading"><a href="/gems/representable">Representable</a></li>
    <li><a href="/gems/representable/getting-started.html">Getting Started</a></li>
    <li><a href="/gems/representable/3.0/api.html">API</a></li>
    <li><a href="/gems/representable/3.0/function-api.html">Function API</a></li>
    <li><a href="/gems/representable/3.0/populator.html">Populator</a></li>
    <!-- <li><a href="/gems/representable/architecture.html">Architecture</a></li> -->
    <li><a href="/gems/representable/3.0/xml.html">XML</a></li>
    <li><a href="/gems/representable/3.0/yaml.html">YAML</a></li>
    <li><a href="/gems/representable/upgrading-guide.html">Upgrading Guide</a></li>
    <li class="divider"></li>

    <li class="heading"><a href="/gems/roar/">Roar</a></li>
    <li><a href="/gems/roar/jsonapi.html">JSON API</a></li>
    <li class="divider"></li>

    <li class="heading"><a href="/gems/disposable/">Disposable</a></li>
    <li><a href="/gems/disposable/api.html">API</a></li>
    <li><a href="/gems/disposable/default.html">Default</a></li>
    <li><a href="/gems/disposable/callback.html">Callback</a></li>
    <li class="divider"></li>

    <li class="heading"><a href="/gems/guides/">Guides</a></li>
    <li><a href="/guides/sinatra/getting-started.html">Sinatra: Getting Started</a></li>
  </ul>
</nav>

      </div>
      <div class="columns medium-9 code-content">
        <h1 id="representable-api">Representable API</h1>

<p>In Representable, we differentiate between three APIs.</p>

<p>The <a href="#declarative-api">declarative API</a> is how we define representers. You can learn how to use those representers by reading about the very brief <a href="#public-api">public API</a>. Representable is extendable without having to hack existing code: the <a href="function-api.html">function API</a> documents how to use its options to achieve what you need.</p>

<h2 id="declarative-api">Declarative API</h2>

<p>To render objects to documents or parse documents to objects, you need to define a representer.</p>

<p>A representer can either be a class (called <em>decorator</em>) or a module (called <em>representer module</em>). Throughout the docs, we will use decorators as they are cleaner and faster, but keep in mind you can also use modules.</p>

<pre><code>require 'representable/json'

class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p>A representer simply defines the fields that will be mapped to the document using <code>property</code> or <code>collection</code>. You can then decorate an object and render or parse. Here’s an example.</p>

<pre><code>SongRepresenter.new(song).to_json #=&gt; {"id": 1, title":"Fallout"}
</code></pre>

<p>The details are being discussed in the <a href="#public-api">public API</a> section.</p>

<h3 id="representer-modules">Representer Modules</h3>

<p>Instead of using classes as representers, you can also leverage modules which will then get mixed into the represented object.</p>

<p>A representer module is also a good way to share configuration and logic across decorators.</p>

<pre><code>module SongRepresenter
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p>The API in a module representer is identical to decorators. However, the way you apply them is different.</p>

<pre><code>song.extend(SongRepresenter).to_json #=&gt; {"id": 1, title":"Fallout"}
</code></pre>

<p>There’s two drawbacks with this approach.</p>

<ol>
  <li>You pollute the represented object with the imported representer methods (e.g. <code>to_json</code>).</li>
  <li>Extending an object at run-time is costly and with many <code>extend</code>s there will be a noteable performance decrease.</li>
</ol>

<p>Throughout this documentation, we will use decorator as examples to encourage this cleaner and faster approach.</p>

<h3 id="collections">Collections</h3>

<p>Not everything is a scalar value. Sometimes an object’s property can be a collection of values. Use <code>collection</code> to represent arrays.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
  collection :composer_ids
end
</code></pre>

<p>The new collection <code>composer_ids</code> has to be enumeratable object, like an array.</p>

<pre><code>Song = Struct.new(:id, :title, :composer_ids)
song = Song.new(1, "Fallout", [2, 3])

song.to_json #=&gt; {"id": 1, title":"Fallout", composer_ids:[2,3]}
</code></pre>

<p>Of course, this works also for parsing. The incoming <code>composer_ids</code> will override the old collection on the represented object.</p>

<h3 id="nesting">Nesting</h3>

<p>Representable can also handle compositions of objects. This works for both <code>property</code> and <code>collection</code>.</p>

<p>For example, a song could nest an artist object.</p>

<pre><code>Song   = Struct.new(:id, :title, :artist)
Artist = Struct.new(:id, :name)

artist = Artist.new(2, "The Police")
song = Song.new(1, "Fallout", artist)
</code></pre>

<p>Here’s a better view of that object graph.</p>

<pre><code>#&lt;struct Song
  id=1,
  title="Fallout",
  artist=#&lt;struct Artist
    id=2,
    name="The Police"&gt;&gt;
</code></pre>

<h3 id="inline-representer">Inline Representer</h3>

<p>The easiest way to nest representers is by using an inline representer.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title

  property :artist do
    property :id
    property :name
  end
end
</code></pre>

<p>Note that you can have any levels of nesting.</p>

<h3 id="explicit-representer">Explicit Representer</h3>

<p>Sometimes you want to compose two existing, stand-alone representers.</p>

<pre><code>class ArtistRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :name
end
</code></pre>

<p>To maximize reusability of representers, you can reference a nested representer using the <code>:decorator</code> option.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title

  property :artist, decorator: ArtistRepresenter
end
</code></pre>

<p>This is identical to an inline representer, but allows you to reuse <code>ArtistRepresenter</code> elsewhere.</p>

<p>Note that the <code>:extend</code> and <code>:decorator</code> options are identical. They can both reference a decorator or a module.</p>

<h3 id="nested-rendering">Nested Rendering</h3>

<p>Regardless of the representer types you use, rendering will result in a nested document.</p>

<pre><code>SongRepresenter.new(song).to_json
#=&gt; {"id": 1, title":"Fallout", artist:{"id":2, "name":"The Police"}}
</code></pre>

<h3 id="nested-parsing">Nested Parsing</h3>

<p>When parsing, per default Representable will want to instantiate an object for every nested, typed fragment.</p>

<p>You have to tell Representable what object to instantiate for the nested <code>artist:</code> fragment.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  # ..
  property :artist, decorator: ArtistRepresenter, class: Artist
end
</code></pre>

<p>This happens via the <code>:class</code> option. Now, the document can be parsed and a nested <code>Artist</code> will be created by the parsing.</p>

<pre><code>song = Song.new # nothing set.

SongRepresenter.new(song).
    from_json('{"id":1,title":"Fallout",artist:{"id":2,"name":"The Police"}}')

song.artist.name #=&gt; "The Police"
</code></pre>

<p>The default behavior is - admittedly - very primitive. Representable’s parsing allow rich mapping, object creation and runtime checks. Read about <a href="populator.html">populators</a> to learn how that works.</p>

<h3 id="document-nesting">Document Nesting</h3>

<p>Not always does the structure of the desired document map to your objects. The <code>::nested</code> method allows structuring properties within a separate section while still mapping the properties to the outer object.</p>

<p>Imagine the following document.</p>

<pre><code>{"title": "Roxanne",
 "details":
   {"track": 3,
    "length": "4:10"}
}
</code></pre>

<p>However, in the <code>Song</code> class, there’s no such concept as <code>details</code>.</p>

<pre><code>Song = Struct.new(:title, :track, :length)
</code></pre>

<p>Both track and length are properties of the song object itself. Representable gives you ::nested to map the virtual <code>details</code> section to the song instance.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title

  nested :details do
    property :track
    property :length
  end
end
</code></pre>

<p>Accessors for the nested properties will still be called on the song object. And as always, this works both ways - for rendering and parsing.</p>

<h3 id="wrapping">Wrapping</h3>

<p>You can automatically wrap a document.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  self.representation_wrap= :song

  property :title
  property :id
end
</code></pre>

<p>This will add a container for rendering and parsing.</p>

<pre><code>SongRepresenter.new(song).to_json
#=&gt; {"song":{"title":"Fallout","id":1}}
</code></pre>

<p>Setting <code>self.representation_wrap = true</code> will advice representable to figure out the wrap itself by inspecting the represented object class.</p>

<p>Note that <code>representation_wrap</code> is a dynamic function option.</p>

<pre><code>self.representation_wrap = -&gt;(user_options:) { user_options[:my_wrap] }
</code></pre>

<p>This would allow to provide the wrap manually.</p>

<pre><code>decorator.to_json(user_options: { my_wrap: "hit" })
</code></pre>

<h3 id="suppressing-nested-wraps">Suppressing Nested Wraps</h3>

<p>When reusing a representer for a nested document, you might want to suppress its <code>representation_wrap=</code> for the nested fragment.</p>

<p>Reusing <code>SongRepresenter</code> from the last section in a nested setup allows suppressing the wrap via the <code>:wrap</code> option.</p>

<pre><code class="language-ruby">class AlbumRepresenter &lt; Representable::Decorator
  include Representable::JSON

  collection :songs,
    decorator: SongRepresenter, # SongRepresenter defines representation_wrap.
     wrap:     false            # turn off :song wrap.
end
</code></pre>

<p>The <code>representation_wrap</code> from the nested representer now won’t be rendered and parsed.</p>

<pre><code class="language-ruby">AlbumRepresenter.new(album).to_json
#=&gt; "{\"songs\": [{\"name\": \"Roxanne\"}]}"
</code></pre>

<p>Note that this only works for JSON and Hash at the moment.</p>

<h3 id="inheritance">Inheritance</h3>

<p>Properties can be inherited across representer classes and modules.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p>What if you need a refined representer to also add the artist. Use inheritance.</p>

<pre><code>class SongWithArtistRepresenter &lt; SongRepresenter
  property :artist do
    property :name
  end
end
</code></pre>

<p>All configuration from <code>SongRepresenter</code> will be inherited, making the properties on <code>SongWithArtistRepresenter</code>: <code>id</code>, <code>title</code>, and <code>artist</code>. The original <code>SongRepresenter</code> will stay as it is.</p>

<h3 id="composition">Composition</h3>

<p>You can also use modules and decorators together to compose representers.</p>

<pre><code>module GenericRepresenter
  include Representable::JSON

  property :id
end
</code></pre>

<p>This can be included in other representers and will extend their configuration.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include GenericRepresenter

  property :title
end
</code></pre>

<p>As a result, <code>SongRepresenter</code> will contain the good old <code>id</code> and <code>title</code> property.</p>

<h3 id="overriding-properties">Overriding Properties</h3>

<p>You might want to override a particular property in an inheriting representer. Successively calling <code>property(name)</code> will override the former definition - exactly as you know it from overriding methods in Ruby.</p>

<pre><code>class CoverSongRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :title, as: :name # overrides that definition.
end
</code></pre>

<h3 id="partly-overriding-properties">Partly Overriding Properties</h3>

<p>Instead of fully replacing a property, you can extend it with <code>:inherit</code>. This will <em>add</em> your new options and override existing options in case the one you provided already existed.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title, as: :name, render_nil: true
end
</code></pre>

<p>You can now inherit properties but still override or add options.</p>

<pre><code>class CoverSongRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :title, as: :songTitle, default: "n/a", inherit: true
end
</code></pre>

<p>Using the :inherit, this will result in a property having the following options.</p>

<pre><code>property :title,
  as:         :songTitle, # overridden in CoverSongRepresenter.
  render_nil: true        # inherited from SongRepresenter.
  default:    "n/a"       # defined in CoverSongRepresenter.
</code></pre>

<p>The <code>:inherit</code> option works for both inheritance and module composition.</p>

<h3 id="inherit-with-inline-representers">Inherit With Inline Representers</h3>

<p><code>:inherit</code> also works applied with inline representers.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title
  property :artist do
    property :name
  end
end
</code></pre>

<p>You can now override or add properties within the inline representer.</p>

<pre><code>class HitRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :artist, inherit: true do
    property :email
  end
end
</code></pre>

<p>Results in a combined inline representer as it inherits.</p>

<pre><code>property :artist do
  property :name
  property :email
end
</code></pre>

<p>Naturally, <code>:inherit</code> can be used within the inline representer block.</p>

<p>Note that the following also works.</p>

<pre><code>class HitRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :artist, as: :composer, inherit: true
end
</code></pre>

<p>This renames the property but still inherits all the inlined configuration.</p>

<p>Basically, <code>:inherit</code> copies the configuration from the parent property, then merges in your options from the inheriting representer. It exposes the same behaviour as <code>super</code> in Ruby - when using <code>:inherit</code> the property must exist in the parent representer.</p>

<h2 id="feature">Feature</h2>

<p>If you need to include modules in all inline representers automatically, register it as a feature.</p>

<pre><code class="language-ruby">class AlbumRepresenter &lt; Representable::Decorator
  include Representable::JSON
  feature Link # imports ::link

  link "/album/1"

  property :hit do
    link "/hit/1" # link method imported automatically.
  end
</code></pre>

<p>Nested representers will <code>include</code> the provided module automatically.</p>

<h2 id="execution-context">Execution Context</h2>

<p>Readers and Writers for properties will usually be called on the <code>represented</code> object. If you want to change that, so the accessors get called on the decorator instead, use <code>:exec_context</code>.</p>

<pre><code class="language-ruby">class SongRepresenter &lt; Representable::Decorator
  property :title, exec_context: :decorator

  def title
    represented.name
  end
end
</code></pre>

<h2 id="callable-options">Callable Options</h2>

<p>While lambdas are one option for dynamic options, you might also pass a “callable” object to a directive.</p>

<pre><code class="language-ruby">class Sanitizer
  include Uber::Callable

  def call(represented, fragment, doc, *args)
    fragment.sanitize
  end
end
</code></pre>

<p>Note how including <code>Uber::Callable</code> marks instances of this class as callable. No <code>respond_to?</code> or other magic takes place here.</p>

<pre><code class="language-ruby">property :title, parse_filter: Santizer.new
</code></pre>

<p>This is enough to have the <code>Sanitizer</code> class run with all the arguments that are usually passed to the lambda (preceded by the represented object as first argument).</p>

<h2 id="readwrite-restrictions">Read/Write Restrictions</h2>

<p>Using the <code>:readable</code> and <code>:writeable</code> options access to properties can be restricted.</p>

<pre><code class="language-ruby">property :title, readable: false
</code></pre>

<p>This will leave out the <code>title</code> property in the rendered document. Vice-versa, <code>:writeable</code> will skip the property when parsing and does not assign it.</p>

<h2 id="coercion">Coercion</h2>

<p>If you need coercion when parsing a document you can use the Coercion module which uses <a href="https://github.com/solnic/virtus">virtus</a> for type conversion.</p>

<p>Include Virtus in your Gemfile, first.</p>

<pre><code class="language-ruby">gem 'virtus', "&gt;= 0.5.0"
</code></pre>

<p>Use the <code>:type</code> option to specify the conversion target. Note that <code>:default</code> still works.</p>

<pre><code class="language-ruby">class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON
  include Representable::Coercion

  property :recorded_at, type: DateTime, default: "May 12th, 2012"
end
</code></pre>

<p>Coercing values only happens when rendering or parsing a document. Representable does not create accessors in your model as <code>virtus</code> does.</p>

<p>Note that we think coercion in the representer is wrong, and should happen on the underlying object. We have a rich <a href="/gems/disposable/coercion.html">coercion/constraint API for twins</a>.</p>

<h2 id="symbol-keys">Symbol Keys</h2>

<p>When parsing, Representable reads properties from hashes using their string keys.</p>

<pre><code class="language-ruby">song.from_hash("title" =&gt; "Road To Never")
</code></pre>

<p>To allow symbol keys also include the <code>AllowSymbols</code> module.</p>

<pre><code class="language-ruby">class SongRepresenter &lt; Representable::Decorator
  include Representable::Hash
  include Representable::Hash::AllowSymbols
  # ..
end
</code></pre>

<p>This will give you a behavior close to Rails’ <code>HashWithIndifferentAccess</code> by stringifying the incoming hash internally.</p>

<h2 id="defaults">Defaults</h2>

<p>The <code>defaults</code> method allows setting options that will be applied to all property definitions of a representer.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults render_nil: true

  property :id
  property :title
end
</code></pre>

<p>This will include <code>render_nil: true</code> in both <code>id</code> and <code>title</code> definitions, as if you’d provided that option each time.</p>

<p>You can also have dynamic option computation at compile-time.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults do |name|
    { as: name.camelize }
  end
</code></pre>

<p>Combining those two forms also works.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults render_nil: true do |name|
    { as: name.camelize }
  end
</code></pre>

<p>All defaults are inherited to subclasses or including modules.</p>

<h2 id="standalone-hash">Standalone Hash</h2>

<p>If it’s required to represent a bare hash object, use <code>Representable::JSON::Hash</code> instead of <code>Representable::JSON</code>.</p>

<p>This is sometimes called a <em>lonely hash</em>.</p>

<pre><code>require "representable/json/hash"

class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Hash
end
</code></pre>

<p>You can then use this hash decorator on instances of <code>Hash</code>.</p>

<pre><code>hash = {"Nick" =&gt; "Hyper Music", "El" =&gt; "Blown In The Wind"}
SongsRepresenter.new(hash).to_json
#=&gt; {"Nick":"Hyper Music","El":"Blown In The Wind"}
</code></pre>

<p>This works both ways.</p>

<p>A lonely hash starts to make sense especially when the values are nested objects that need to be represented, too. You can configure the nested value objects using the <code>values</code> method. This works exactly as if you were defining an inline representer, accepting the same options.</p>

<pre><code>class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Hash

  values class: Song do
    property :title
  end
end
</code></pre>

<p>You can now represents nested objects in the hash, both rendering and parsing-wise.</p>

<pre><code>hash = {"Nick" =&gt; Song.new("Hyper Music")}
SongsRepresenter.new(hash).to_json
</code></pre>

<p>In XML, use <code>XML::Hash</code>. If you want to store hash attributes in tag attributes instead of dedicated nodes, use <code>XML::AttributeHash</code>.</p>

<h2 id="standalone-collection">Standalone Collection</h2>

<p>Likewise, you can represent <em>lonely collections</em>, instances of <code>Array</code>.</p>

<pre><code>require "representable/json/collection"

class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Collection

  items class: Song do
    property :title
  end
end
</code></pre>

<p>Here, you define how to represent items in the collection using <code>items</code>.</p>

<p>Note that the items can be simple scalar values or deeply nested objects.</p>

<pre><code>ary = [Song.new("Hyper Music"), Song.new("Screenager")]
SongsRepresenter.new(ary).to_json
#=&gt; [{"title":"Hyper Music"},{"title":"Screenager"}]
</code></pre>

<p>Note that this also works for XML.</p>

<h2 id="standalone-collection-toa">Standalone Collection: to_a</h2>

<p>Another trick to represent collections is using a normal representer with exactly one collection property named <code>to_a</code>.</p>

<pre><code>class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON # note that this is a plain representer.

  collection :to_a, class: Song do
    property :title
  end
end
</code></pre>

<p>You can use this representer the way you already know and appreciate, but directly on an array.</p>

<pre><code>ary = []
SongsRepresenter.new(ary).from_json('[{"title": "Screenager"}]')
</code></pre>

<p>In order to grab the collection for rendering or parsing, Representable will now call <code>array.to_a</code>, which returns the array itself.</p>

<h2 id="automatic-collection-representer">Automatic Collection Representer</h2>

<p>Instead of explicitly defining representers for collections using a <a href="#standalone-collection">“lonely collection”</a>, you can let Representable  do that for you.</p>

<p>Rendering a collection of objects comes for free, using <code>for_collection</code>.</p>

<pre><code>songs = Song.all
SongRepresenter.new(songs).for_collection).to_json
#=&gt; '[{"title": "Sevens"}, {"title": "Eric"}]'
</code></pre>

<p>For parsing, you need to provide the class for the nested items. This happens via `collection_representer</p>

<pre><code class="language-ruby">class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON
  property :title

  collection_representer class: Song
end
</code></pre>

<p>You can now parse collections to <code>Song</code> instances.</p>

<pre><code>songs = Song.all
json  = '[{"title": "Sevens"}, {"title": "Eric"}]'

SongRepresenter.new(songs).for_collection).from_json(json)
</code></pre>

<p>Note: the implicit collection representer internally is implemented using a lonely collection. Everything you pass to <code>::collection_representer</code> is simply provided to the <code>::items</code> call in the lonely collection. That allows you to use <code>:populator</code> and all the other goodies, too.</p>

<h2 id="automatic-singular-and-collection">Automatic Singular and Collection</h2>

<p>In case you don’t want to know whether or not you’re working with a collection or singular model, use <code>represent</code>.</p>

<pre><code># singular
SongRepresenter.represent(Song.find(1)).to_json
#=&gt; '{"title": "Sevens"}'

# collection
SongRepresenter.represent(Song.all).to_json
#=&gt; '[{"title": "Sevens"}, {"title": "Eric"}]' ```
</code></pre>

<p><code>represent</code> figures out the correct representer for you. This works for parsing, too.</p>

<h2 id="public-api">Public API</h2>

<p>When decorating an object with a representer, the object needs to provide readers for every defined <code>property</code> - and writers, if you’re planning to parse.</p>

<h3 id="accessors">Accessors</h3>

<p>In our small <code>SongRepresenter</code> example, the represented object has to provide <code>#id</code> and <code>#title</code> for rendering.</p>

<pre><code>Song = Struct.new(:id, :title)
song = Song.new(1, "Fallout")
</code></pre>

<h3 id="rendering">Rendering</h3>

<p>You can render the document by decorating the object and calling the serializer method.</p>

<pre><code>SongRepresenter.new(song).to_json #=&gt; {"id":1, title":"Fallout"}
</code></pre>

<p>When rendering, the document fragment is read from the represented object using the getter (e.g. <code>Song#id</code>).</p>

<p>Since we use <code>Representable::JSON</code> the serializer method is <code>#to_json</code>.</p>

<p>For other format engines the serializer method will have the following name.</p>

<ul>
  <li><code>Representable::JSON#to_json</code></li>
  <li><code>Representable::JSON#to_hash</code> (provides a hash instead of string)</li>
  <li><code>Representable::Hash#to_hash</code></li>
  <li><code>Representable::XML#to_xml</code></li>
  <li><code>Representable::YAML#to_yaml</code></li>
</ul>

<h3 id="parsing">Parsing</h3>

<p>Likewise, parsing will read values from the document and write them to the represented object.</p>

<pre><code>song = Song.new
SongRepresenter.new(song).from_json('{"id":1, "title":"Fallout"}')
song.id    #=&gt; 1
song.title #=&gt; "Fallout"
</code></pre>

<p>When parsing, the read fragment is written to the represented object using the setter (e.g. <code>Song#id=</code>).</p>

<p>For other format engines, the deserializing method is named analogue to the serializing counterpart, where <code>to</code> becomes <code>from</code>. For example, <code>Representable::XML#from_xml</code> will parse XML if the format engine is mixed into the representer.</p>

<h3 id="user-options">User Options</h3>

<p>You can provide options when representing an object using the <code>user_options:</code> option.</p>

<pre><code>decorator.to_json(user_options: { is_admin: true })
</code></pre>

<p>Note that the <code>:user_options</code> will be accessable on all levels in a nested representer. They act like a “global” configuration and are passed to all option functions.</p>

<p>Here’s an example where the <code>:if</code> option function evaluates a dynamic user option.</p>

<pre><code>property :id, if: -&gt;(options) { options[:user_options][:is_admin] }
</code></pre>

<p>This property is now only rendered or parsed when <code>:is_admin</code> is true.</p>

<p>Using Ruby 2.1’s keyword arguments is highly recommended - to make that look a bit nicer.</p>

<pre><code>property :id, if: -&gt;(user_options:, **) { user_options[:is_admin] }
</code></pre>

<h3 id="nested-user-options">Nested User Options</h3>

<p>Representable also allows passing nested options to particular representers. You have to provide the property’s name to do so.</p>

<pre><code>decorator.to_json(artist: { user_options: { is_admin: true } })
</code></pre>

<p>This will pass the option to the nested <code>artist</code>, only. Note that this works with any level of nesting.</p>

<h3 id="include-and-exclude">Include and Exclude</h3>

<p>Representable supports two top-level options.</p>

<p><code>:include</code> allows defining a set of properties to represent. The remaining will be skipped.</p>

<pre><code>decorator.to_json(include: [:id])  #=&gt; {"id":1}
</code></pre>

<p>The other, <code>:exclude</code>, will - you might have guessed it already - skip the provided properties and represent the remaining.</p>

<pre><code>decorator.to_json(exclude: [:id, :artist])  #=&gt; {"title":"Fallout"}
</code></pre>

<p>As always, these options work both ways, for rendering <em>and</em> parsing.</p>

<p>Note that you can also nest <code>:include</code> and <code>:exclude</code>.</p>

<pre><code>decorator.to_json(artist: { include: [:name] })
#=&gt; {"id":1, "title":"Fallout", "artist":{"name":"Sting"}}
</code></pre>

<h3 id="tohash-and-fromhash">to_hash and from_hash</h3>

      </div>
    </div>

    <!-- Footer -->
<section class="sub-section top-footer">
  <div class="row">
	<div class="columns medium-6">
		<h3>Newsletter</h3>
		<p>
			Stay on top of what’s happening in Trailblazer.
		</p>
			<div class="row">
				<div id="mc_embed_signup">
		     	<form action="//trailblazerb.us8.list-manage.com/subscribe/post?u=bbe5021ab6fbdc94a16f0d036&amp;id=a69f6e4652" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>

						<div class="columns large-9 medium-12 ">
							<div class="row collapse prefix-radius">
				        <div class="small-8 medium-7 large-8 columns">
				        	<div id="mc_embed_signup_scroll">
				        		<div class="mc-field-group">
									  	<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="youremail@trailblazer.to">
									  </div>
									  <div id="mce-responses" class="clear">
									    <div class="response" id="mce-error-response" style="display:none"></div>
									    <div class="response" id="mce-success-response" style="display:none"></div>
									  </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
									  <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_bbe5021ab6fbdc94a16f0d036_a69f6e4652" tabindex="-1" value=""></div>

				        	</div>
				        </div>
				        <div class="small-4 medium-5 large-4 columns">
				          <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button postfix secondary">
				        </div>
				      </div>
						</div>
					</form>
				</div>
				<script type='text/javascript' src='//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js'></script><script type='text/javascript'>(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';}(jQuery));var $mcj = jQuery.noConflict(true);</script>
			</div>
		<p>
			And check out the <a href="/newsletter/">archive of newsletters</a>!
		</p>


	</div>
	<div class="columns medium-6">
		<h3>The Book</h3>
		<p>Learn how to built a Rails app with Trailblazer, step-by-step.</p>
		<a href="/books/trailblazer.html" class="button radius tiny secondary">Check Out Book!</a>
	</div>
</div>


</section>

<footer>
  <div class="row">
    <div class="columns medium-4">
      <div class="logo-box">
        <a href="/"><img src="/images/icon_trb.png">
        </a>
      </div>
    </div>
    <div class="columns medium-8">
      <div class="row">
        <div class="columns medium-6">
          <h4>
            Trailblazer
          </h4>
          <ul class="no-bullet">
            <li><a href="https://gitter.im/trailblazer/chat">Gitter chat</a></li>
            <li><a href="https://leanpub.com/trailblazer">The book</a></li>
          </ul>
        </div>
        <div class="columns medium-6">
          <h4>
            Follow Us
          </h4>
          <ul class="inline-list">
            <li>
              <a href="https://github.com/trailblazer">
                <i class="footer-icon github-icon"></i>
              </a>
            </li>
            <li>
              <a href="https://twitter.com/apotonick">
                <i class="footer-icon twitter-icon"></i>
              </a>
            </li>
          </ul>
        </div>
      </div>
      <p class="copyright">
        Trailblazer is created by <a href="https://github.com/apotonick">Nick Sutterer</a> and awesome friends.
      </p>
      <p class="copyright">
        Site designed and handcoded with love by <a href="https://twitter.com/noeliacabane">Noelia Cabane</a>
      </p>
    </div>
  </div>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69514939-1', 'auto');
  ga('send', 'pageview');

</script>

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/bower_components/jquery/jquery.js"><\/script>')</script>
<script src="/javascripts/plugins.js"></script>
<script src="/bower_components/foundation/js/foundation.min.js"></script>
<script src="/javascripts/script.js"></script>

<script src="/bower_components/anchor-js/anchor.js"></script>
<script>
  anchors.add(".code-content h2, .sub-section h2");
</script>


<script>
  $(document).foundation();
</script>

  </body>
</html>
