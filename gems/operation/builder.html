<h1 id="builder">Builder</h1>

<p>Different contexts like <em>“admin user”</em> vs. <em>“signed in”</em> can be handled in the same code asset along with countless <code>if</code>s and <code>else</code>s. Or, you can use polymorphism as it is encouraged by Trailblazer.</p>

<p>The easiest way is to use normal inheritance for context-specific operations.</p>

<pre><code>class Thing::Create &lt; Trailblazer::Operation
  # generic code, contracts, etc.

  class SignedIn &lt; self
    # specific code
  end
end
</code></pre>

<p>A <code>builds</code> block allows to let the operation class take care of the instantiation process.</p>

<pre><code>class Thing::Create &lt; Trailblazer::Operation
  builds -&gt; (params) do
    return SignedIn if params[:current_user]
  end
</code></pre>

<p>When running the top-level operation, the builder will instantiate the correct subclass according to the <code>params</code> environment.</p>

<pre><code>op = Thing::Create.(current_user: admin)
op.class #=&gt; Thing::Create::SignedIn
</code></pre>

<p>If the <code>builds</code> block doesn’t return a constant, the original constant will be used for instantiation. In our example, this would resolve to <code>Thing::Create</code>.</p>

<h2 id="shared-builders">Shared Builders</h2>

<p><code>builds</code> blocks are <em>not inherited</em>. You can copy them to other classes, though.</p>

<pre><code>class Thing::Update &lt; Trailblazer::Operation
  self.builds_class = Create.build_class
</code></pre>

<p>Be careful about constant resolving here: the block you copied has to have runtime evaluation of constants.</p>

<pre><code>class Thing::Create &lt; Trailblazer::Operation
  builds -&gt; (params) do
    return self::SignedIn if # ...
  end
</code></pre>

<p>Now, the block can safely be copied to other classes where <code>SignedIn</code> will be resolved in the new context.</p>

<h2 id="resolver">Resolver</h2>

<p>A resolver allows you to use both the operation model and the policy in the builder.</p>

<pre><code>class Thing::Create &lt; Trailblazer::Operation
  include Resolver

  policy Thing::Policy, :create?
  model Thing, :create

  builds -&gt; (model, policy, params)
    return Admin if policy.admin?
    return SignedIn if params[:current_user]
  end
</code></pre>

<p>Please note that the <code>builds</code> block is run in class context, no operation instance is available, yet. It is important to understand that <code>Resolver</code> also changes the way the operation’s model is created/found. This, too, happens on the class layer, now.</p>

<p>You have to configure the CRUD module using <code>::model</code> so the operation can instantiate the correct model for the builder.</p>

<p>If you want to change the way the model is created, you have to do so on the class level.</p>

<pre><code>class Thing::Create &lt; Trailblazer::Operation
  include Resolver
  # ..

  def self.model!(params)
    Thing.find_by(slug: params[:slug])
  end
</code></pre>

<p>Do <em>not</em> include <code>CRUD</code> when using <code>Resolver</code>.</p>
