<h1 id="policy">Policy</h1>

<p>Trailblazer supports “pundit-style” policy classes. They can be hooked into operations and prevent the operation from running its <code>#process</code> method by raising an exception if the policy rule returned <code>false</code>.</p>

<h2 id="policy-classes">Policy Classes</h2>

<p>The format of a policy class is heavily inspired by the excellent <a href="https://github.com/elabs/pundit">Pundit</a> gem. In fact, you can reuse your pundit policies without any code changes in Trailblazer.</p>

<p>A policy file per concept is recommendable.</p>

<pre><code>class Thing::Policy
  def initialize(user, thing)
    @user, @thing = user, thing
  end

  def create?
    admin?
  end

  def admin?
    @user.admin == true
  end
  # ..
end
</code></pre>

<p>This class would probably be best located at <code>app/concepts/thing/policy.rb</code>.</p>

<h2 id="operation-policy">Operation Policy</h2>

<p>Use <code>::policy</code> to hook the policy class along with a query action into your operation.</p>

<pre><code>class Thing::Create &lt; Trailblazer::Operation
  include Policy

  policy Thing::Policy, :create?
</code></pre>

<p>The policy is evaluated in <code>#setup!</code>, raises an exception if <code>false</code> and thus suppresses running <code>#process</code>. It is a great way to protect your operations from unauthorized users.</p>

<pre><code>Thing::Create.(current_user: User.find_normal_user, thing: {})
</code></pre>

<p>This will raise a <code>Trailblazer::NotAuthorizedError</code>.</p>

<h2 id="policy-creation">Policy Creation</h2>

<p>To instantiate the <code>Thing::Policy</code> object internally, per default the <code>params[:current_user]</code> and the operation’s <code>model</code> is passed into the constructor. You can override that via <code>Operation#evaluate_policy</code>.</p>

<h2 id="queries">Queries</h2>

<p>After <code>#setup!</code>, the policy instance is available at any point in your operation code.</p>

<pre><code>def process(params)
  notify_admin! if policy.admin?
</code></pre>

<p>This won’t raise an exception.</p>

<h2 id="pundit">Pundit</h2>

<p>Pundit policy classes can be used directly in operations.</p>

<pre><code>class Thing::Create &lt; Trailblazer::Operation
  include Policy
  policy ThingPolicy, :create?
</code></pre>

<p>As a matter of course, you may call other rule queries on the internal policy object later on.</p>

<h2 id="guard">Guard</h2>

<p>Instead of using policies, you can also use a simple guard. A guard is like an inline policy that doesn’t require you to define a policy class. It is run in <code>#setup!</code>, too, like a real policy, but isn’t accessable in the operation after that.</p>

<pre><code>class Thing::Create &lt; Trailblazer::Operation
  include Policy::Guard

  policy-&gt; (params) do
    return false if params[:current_user].nil?
  end
</code></pre>

<p>Note that you can’t mix <code>Policy</code> and guards in one class.</p>

<h2 id="resolver">Resolver</h2>

<p>You can use policies in your builders, too. Please refer to the <a href="builder.html#resolver">builder docs</a> to learn about that.</p>
